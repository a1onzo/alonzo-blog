---
title: java-note
date: 2020-04-07 15:15:57
tags: java
---



# Java 笔记



## 1. java语言简介

### 1.1 语言类型

语言类型： 解释型语言 （c,c++,golang等属于编译型语言）

> 编译型语言：提前编译成机器识别的二进制，每次运行只需要执行二进制，效率高，跨平台差。
>
> 解释型语言：每次执行时通过解释器翻译成机器语言，跨平台好，效率低。



### 1.2 java三个版本

- Java SE: Standard Edition  标准版。包含标准JVM和标准库
- Java EE: Enterprise Edition 企业版。在java SE基础上，加了诸如web,数据库,消息队列等api，方便企业应用开发
- java ME: Micro Edition 嵌入式版



### 1.3 jdk和jre

- JDK：Java Development Kit。只包含虚拟机
- JRE：Java Runtime Environment。除了虚拟机还包含编译器，调试器等开发工具

关系图：

```ascii
  ┌─    ┌──────────────────────────────────┐
  │     │     Compiler, debugger, etc.     │
  │     └──────────────────────────────────┘
 JDK ┌─ ┌──────────────────────────────────┐
  │  │  │                                  │
  │ JRE │      JVM + Runtime Library       │
  │  │  │                                  │
  └─ └─ └──────────────────────────────────┘
        ┌───────┐┌───────┐┌───────┐┌───────┐
        │Windows││ Linux ││ macOS ││others │
        └───────┘└───────┘└───────┘└───────┘
```



## 2. java语言基础

### 2.1 类和方法

java是面向对象语言。java程序的基本单位就是类`class`

类名要求：必须以英文字母开头，后接字母，数字和下划线的组合。通常用驼峰法

方法命名要求： 和类名要求一样。同样驼峰法，不过通常首字母小写

### 2.2 java入口

程序规定的方法必须是静态方法，方法名必须为`main`，括号内的参数必须是String数组

### 2.3 变量

java中变量分两种

- 基本类型
- 引用类型

#### 2.3.1 基本类型

基本数据类型是CPU可以直接进行运算的类型

- 整数类型: byte (1) , short (2), int(4) , long (8)
- 浮点类型: float (4) ,double(8)
- 字符类型: char(2)
- 布尔类型: boolean(2)

计算机内存的最小存储单元是字节

#### 2.3.2 引用类型

存储地址

#### 2.3.3 常量

加上`final`修饰的变量就变成了常量，定义时初始化。之后不能更改。







## 3. 面向对象

基本概念：类，实例，方法

特性：继承，多态，封装



### 3.1 构造方法

类的初始化函数。方法名和类名一致。

构造方法可以重载。



### 3.2 继承

Java使用`extends`关键字来实现继承

所有类都默认继承自`Object`类

OOP术语：

父类：超类（super class），父类（parent class），基类（base class）

子类：子类（subclass），扩展类（extended class）



一个类有且仅有一个父类。只有`Object`特殊，它没有父类。

`protected`关键字可以把字段和方法的访问权限控制在继承树内部



子类访问父类：

`super`关键字表示父类（超类）。子类引用父类的字段时，可以用`super.fieldName`



子类构造函数：

在Java中，任何`class`的构造方法，第一行语句必须是调用父类的构造方法。如果没有明确地调用父类的构造方法，编译器会帮我们自动加一句`super()`。

如果父类没有默认的构造方法，子类就必须显式调用`super()`并给出参数以便让编译器定位到父类的一个合适的构造方法。 因为如果父类没有默认的无参数的构造方法，在子类中就必须要手动通过`super`调用父类的构造方法，否则，默认调用的父类的`super()`没有，会编译错误。



向上转型：

子类类型安全地变为父类类型的赋值，被称为向上转型（upcasting）。子类是父类的超集

如果向下转型会报错`ClassCastException`



instanceof 关键词:

为了避免向下转型出错，Java提供了`instanceof`操作符，可以先判断一个实例究竟是不是某种类型.



继承和组合

继承是is关系，组合是has关系。



### 3.3 多态

多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。



`final`修饰：

用`final`修饰的方法不能被`Override`

用`final`修饰的类不能被继承



### 3.4 重载和重写

重写与重载之间的区别

| 区别点   | 重载方法 | 重写方法                                       |
| :------- | :------- | :--------------------------------------------- |
| 参数列表 | 必须修改 | 一定不能修改                                   |
| 返回类型 | 可以修改 | 一定不能修改                                   |
| 异常     | 可以修改 | 可以减少或删除，一定不能抛出新的或者更广的异常 |
| 访问     | 可以修改 | 一定不能做更严格的限制（可以降低限制）         |

总结

方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。

- (1)方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。
- (2)方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。
- (3)方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。



### 3.5 抽象类

`abstract` 修饰词表示抽象。

可以定义抽象类，抽象方法。

一些特性：

1. 抽象类无法实例化，只能用于继承。
2. 抽象类不一定包含抽象方法，但包含抽象方法的类一定是抽象类。

面向抽象编程：

- 上层代码只定义规范
- 不需要子类就可以实现业务逻辑（正常编译）
- 具体的业务逻辑由不同的子类实现，调用者并不关心



### 3.6 接口

接口定义的所有方法默认也只能是 `public abstract`

实现一个`interface`时，需要使用`implements`关键字

一个类可以实现多个接口

接口本质是把行为抽象

接口可以通过继承扩展：一个`interface`可以继承自另一个`interface`。`interface`继承自`interface`使用`extends`，它相当于扩展了接口的方法

`default`方法：

新增的是`default`方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。



### 3.7 静态字段和方法

`static`修饰的字段，称为静态字段：`static field`。

可以直接用类名加字段名访问

用`static`修饰的方法称为静态方法。

调用静态方法则不需要实例变量，通过类名就可以调用。

静态方法内部无法使用this，只能访问静态字段。

`interface`是一个纯抽象类，所以它不能定义实例字段。但是，`interface`是可以有静态字段的，并且静态字段必须为`final`类型。`interface`的字段只能是`public static final`类型，所以我们可以把这些修饰符都去掉。



### 3.8 访问修饰词

![Java的访问权限修饰词：public, default, protected和private - Break易站](https://cdn.breakyizhan.com/wp-content/uploads/2017/12/JavaMind6_1-2.png)





## 4. JDK核心类

### 4.1 字符串和编码

#### 4.1.1 String

`String` 是引用类型。内容不可变，内部本质是一个`private final char value[]` 来存储字符串内容。

#### 4.1.2 字符串比较

```
public class Main {
    public static void main(String[] args) {
        String s = "hello";
        String s1= "hello";
        System.out.printf("%b\n", (s==s1));
        System.out.printf("%b\n", (s.equals(s1)));
    }
}
```

结果都为true。但是是因为相同的字符串当作一个对象放入常量池。

`== `判断的是引用变量本身是否相等。

`equals()`方法才会去比较字符串内容是否相等，所以要判断字符串是否相等要用 `equals()` 方法。

#### 4.1.3 字符串与其他类型的转换

任意基本类型或引用类型转换为字符串，可以使用静态方法`valueOf()`

```
String.valueOf(123); // "123"
String.valueOf(45.67); // "45.67"
String.valueOf(true); // "true"
String.valueOf(new Object()); // 类似java.lang.Object@636be97c
```

要把字符串转换为其他类型，就需要根据情况。例如，把字符串转换为`int`类型：

```
int n1 = Integer.parseInt("123"); // 123
int n2 = Integer.parseInt("ff", 16); // 按十六进制转换，255
```

把字符串转换为`boolean`类型：

```
boolean b1 = Boolean.parseBoolean("true"); // true
boolean b2 = Boolean.parseBoolean("FALSE"); // false
```

`String`和`char[]`类型可以互相转换，方法是：

```
char[] cs = "Hello".toCharArray(); // String -> char[]
String s = new String(cs); // char[] -> String
```

#### 4.1.4 字符编码

> `ASCII`编码：一个字节，编码范围从`0`到`127`，最高位始终为`0``
>
> ``Unicode`编码：为了统一所有语言的编码，两个字节，固定长度，有些字符，比如英文字符会有空间浪费。
>
> `UTF-8`编码：可变长编码，压缩处理的编码。依靠高字节位来确定一个字符究竟是几个字节。

Java使用Unicode编码表示`String`和`char`



#### 4.1.5 StringBuilder  / StringBuffer

`StringBuilder ` 非线程安全，效率高。 `StringBuffer`线程安全，效率下降。

StringBuilder 其实就是内容可变的String。 

### 4.2 包装类型

Java核心库为每种基本类型都提供了对应的包装类型。

自动装箱和拆箱，不需要手动调用方法去转换。

```
Integer n = 100; // 编译器自动使用Integer.valueOf(int)
int x = n; // 编译器自动使用Integer.intValue()
```

一些特点：

1. 基本类型的包装类型都是不可变类型。 比如Integer内部用 private final int value;存储
2. 包装类型的内容比较 用`equals()`，`==`比较的是引用类型。

特别注意：较小的数，为了节省内存，`Integer.valueOf()`对于较小的数（**-128~127**），返回相同的实例重用。所以有可能 `==`也会为true。

### 4.3 枚举类

#### 4.3.1 enum的使用

`enum`关键词可以定义枚举类

```
public class Main {
    public static void main(String[] args) {
        Weekday day = Weekday.SUN;
        if (day == Weekday.SAT || day == Weekday.SUN) {
            System.out.println("Work at home!");
        } else {
            System.out.println("Work at office!");
        }
    }
}
enum Weekday {
    SUN, MON, TUE, WED, THU, FRI, SAT;
}
```

#### 4.3.2 enum的比较

前面提过`==` 比较引用，`equals()`比较的是引用内容。

但是枚举类型可以用`==`。因为枚举类型都是常量，在JVM中只有唯一一个实例。所以只要内容相等,`==`也是相等的

```
if (day == Weekday.FRI) { // ok!
}
if (day.equals(Weekday.SUN)) { // ok, but more code!
}
```

#### 4.3.3 enum和class的区别

`enum`定义的类型就是`class`，只不过它有以下几个特点：

- 定义的`enum`类型总是继承自`java.lang.Enum`，且无法被继承；
- 只能定义出`enum`的实例，而无法通过`new`操作符创建`enum`的实例；
- 定义的每个实例都是引用类型的唯一实例；
- 可以将`enum`类型用于`switch`语句

### 4.4 BigInteger / BigDecimal



#### 4.4.1 BigInteger/BigDecimal 使用

`java.math.BigInteger`就是用来表示任意大小的整数。`BigInteger`内部用一个`int[]`数组来模拟一个非常大的整数

```
BigInteger bi = new BigInteger("1234567890");
System.out.println(bi.pow(5)); // 2867971860299718107233761438093672048294900000
```

和`BigInteger`类似，`BigDecimal`可以表示一个任意大小且精度完全准确的浮点数。

```
BigDecimal bd = new BigDecimal("123.4567");
System.out.println(bd.multiply(bd)); // 15241.55677489
```



#### 4.4.2 BigInteger其他类型的转化

`BigInteger`和`Integer`、`Long`一样，也是不可变类，并且也继承自`Number`类。因为`Number`定义了转换为基本类型的几个方法：

- 转换为`byte`：`byteValue()`
- 转换为`short`：`shortValue()`
- 转换为`int`：`intValue()`
- 转换为`long`：`longValue()`
- 转换为`float`：`floatValue()`
- 转换为`double`：`doubleValue()`

因此，通过上述方法，可以把`BigInteger`转换成基本类型。如果`BigInteger`表示的范围超过了基本类型的范围，转换时将丢失高位信息，即结果不一定是准确的。如果需要准确地转换成基本类型，可以使用`intValueExact()`、`longValueExact()`等方法，在转换时如果超出范围，将直接抛出`ArithmeticException`异常。



## 5. 异常处理



### 5.1 Java的异常

java异常体系图：

```ascii
                     ┌───────────┐
                     │  Object   │
                     └───────────┘
                           ▲
                           │
                     ┌───────────┐
                     │ Throwable │
                     └───────────┘
                           ▲
                 ┌─────────┴─────────┐
                 │                   │
           ┌───────────┐       ┌───────────┐
           │   Error   │       │ Exception │
           └───────────┘       └───────────┘
                 ▲                   ▲
         ┌───────┘              ┌────┴──────────┐
         │                      │               │
┌─────────────────┐    ┌─────────────────┐┌───────────┐
│OutOfMemoryError │... │RuntimeException ││IOException│...
└─────────────────┘    └─────────────────┘└───────────┘
                                ▲
                    ┌───────────┴─────────────┐
                    │                         │
         ┌─────────────────────┐ ┌─────────────────────────┐
         │NullPointerException │ │IllegalArgumentException │...
         └─────────────────────┘ └─────────────────────────┘
```



从继承关系可知：`Throwable`是异常体系的根，它继承自`Object`。`Throwable`有两个体系：`Error`和`Exception`，`Error`表示严重的错误，程序对此一般无能为力，例如：

- `OutOfMemoryError`：内存耗尽
- `NoClassDefFoundError`：无法加载某个Class
- `StackOverflowError`：栈溢出

而`Exception`则是运行时的错误，它可以被捕获并处理。

某些异常是应用程序逻辑处理的一部分，应该捕获并处理。例如：

- `NumberFormatException`：数值类型的格式错误
- `FileNotFoundException`：未找到文件
- `SocketException`：读取网络失败

还有一些异常是程序逻辑编写不对造成的，应该修复程序本身。例如：

- `NullPointerException`：对某个`null`的对象调用方法或字段
- `IndexOutOfBoundsException`：数组索引越界

`Exception`又分为两大类：

1. `RuntimeException`以及它的子类；
2. 非`RuntimeException`（包括`IOException`、`ReflectiveOperationException`等等）

Java规定：

- 必须捕获的异常，包括`Exception`及其子类，但不包括`RuntimeException`及其子类，这种类型的异常称为Checked Exception。
- 不需要捕获的异常，包括`Error`及其子类，`RuntimeException`及其子类。



### 5.2 捕获异常

捕获异常使用`try...catch`语句，把可能发生异常的代码放到`try {...}`中，然后使用`catch`捕获对应的`Exception`及其子类。

`RuntimeException`无需强制捕获，非`RuntimeException`（Checked Exception）需强制捕获，或者用`throws`声明继续往上层抛；

```
public class Main {
    public static void main(String[] args) {
        byte[] bs = toGBK("中文");
        System.out.println(Arrays.toString(bs));
    }

    static byte[] toGBK(String s) {
        try {
            // 用指定编码转换String为byte[]:
            return s.getBytes("GBK");
        } catch (UnsupportedEncodingException e) {
            // 如果系统不支持GBK编码，会捕获到UnsupportedEncodingException:
            System.out.println(e); // 打印异常信息
            return s.getBytes(); // 尝试使用用默认编码
        }
    }
}
```

finally语句可保证有无异常都执行，即:

```
try{
	...
} catch(Exception e) {
	... 
} catch(Exception e) {
	...
} finally {
	... //最后总会执行
}
```



### 5.3 抛出异常

某个方法抛出了异常时，如果当前方法没有捕获异常，异常就会被抛到上层调用方法，直到遇到某个`try ... catch`被捕获为止

```
    if (s==null) {
        throw new NullPointerException();
    }
```

在`catch`中抛出异常，不会影响`finally`的执行。JVM会先执行`finally`，然后抛出异常。

如果在finally中抛出异常，可能会导致catch中的异常不会抛出。所以finally中尽量不要抛出异常。

例子：

```
public class Main {
    public static void main(String[] args) {
        try {
            process1();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    static void process1() {
        try {
            process2();
        } catch (NullPointerException e) {
            throw new IllegalArgumentException(e);
        }
    }

    static void process2() {
        throw new NullPointerException();
    }
}
```

执行结果：

```
java.lang.IllegalArgumentException: java.lang.NullPointerException
    at Main.process1(Main.java:15)
    at Main.main(Main.java:5)
Caused by: java.lang.NullPointerException
    at Main.process2(Main.java:20)
    at Main.process1(Main.java:13
```



### 5.4 Java标准库常用异常

Java标准库定义的常用异常包括：

```ascii
Exception
│
├─ RuntimeException
│  │
│  ├─ NullPointerException
│  │
│  ├─ IndexOutOfBoundsException
│  │
│  ├─ SecurityException
│  │
│  └─ IllegalArgumentException
│     │
│     └─ NumberFormatException
│
├─ IOException
│  │
│  ├─ UnsupportedCharsetException
│  │
│  ├─ FileNotFoundException
│  │
│  └─ SocketException
│
├─ ParseException
│
├─ GeneralSecurityException
│
├─ SQLException
│
└─ TimeoutException
```

### 5.5 断言

使用`assert`关键字来实现断言

```
public static void main(String[] args) {
    int x = -1;
    assert x >= 0 : "x must >= 0";
    System.out.println(x);
}
```



## 6. 反射

### 6.1 Class类

Class类存储类的元数据。在JVM中唯一实例，JVM每加载一种class，就会创建一个Class类的实例，并在实例中保存了该`class`的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等。

只有JVM能创建Class类。

JVM持有的每个`Class`实例都指向一个数据类型（`class`或`interface`）

可以通过该`Class`实例来创建对应类型的实例，但是只能调用public无参数构造方法：

```
// 获取String的Class实例:
Class cls = String.class;
// 创建一个String实例:
String s = (String) cls.newInstance();
```

jvm对Class是动态加载，只有在用到的时候才回去创建Class实例。



## 7. 泛型

泛型是定义一种模版，例如`ArrayList`，然后在代码中为用到的类创建对应的`ArrayList<类型>`



extends关键字可以限定泛型类型：

`public class Pair<T extends Number> { ... }`



## 8. 集合



### 8.3 Map

`Map`用于存储key-value的映射，对于充当key的对象，是不能重复的，并且，不但需要正确覆写`equals()`方法，还要正确覆写`hashCode()`方法。

```ascii
       ┌───┐
       │Map│
       └───┘
         ▲
    ┌────┴─────┐
    │          │
┌───────┐ ┌─────────┐
│HashMap│ │SortedMap│
└───────┘ └─────────┘
               ▲
               │
          ┌─────────┐
          │ TreeMap │
          └─────────┘
```



### 8.4 Set



```ascii
       ┌───┐
       │Set│
       └───┘
         ▲
    ┌────┴─────┐
    │          │
┌───────┐ ┌─────────┐
│HashSet│ │SortedSet│
└───────┘ └─────────┘
               ▲
               │
          ┌─────────┐
          │ TreeSet │
          └─────────┘
```



## 9. IO

IO流是一种流式的数据输入/输出模型：

- 二进制数据以`byte`为最小单位在`InputStream`/`OutputStream`中单向流动；
- 字符数据以`char`为最小单位在`Reader`/`Writer`中单向流动。

Java标准库的`java.io`包提供了同步IO功能：

- 字节流接口：`InputStream`/`OutputStream`；
- 字符流接口：`Reader`/`Writer`。



## 10. 多线程



### 10.1 线程生命周期

![img](https://www.runoob.com/wp-content/uploads/2014/01/java-thread.jpg)



### 10.2 创建线程

Java 提供了三种创建线程的方法：

- 通过实现 Runnable 接口；
- 通过继承 Thread 类本身；
- 通过 Callable 和 Future 创建线程。



Callable 通过包装成FutureTask ，new Thread的时候作为参数传递

或者通过ExecutorService的submit

Runable 可以new Thread的时候作为参数传递或者通过ExecutorService的execute方法

Callable可以有返回值，Runnable没有。Callable能获取状态，Runnable不行。





## 11. 内存管理

内存分区：

![img](https://pic3.zhimg.com/80/v2-5608d5d79b587f984a8725abab6bf526_1440w.jpg)



1. 方法区， class元数据，常量，静态变量
2. 栈：局部变量
3. 堆：对象实例和数组
4. 程序计数器：控制字节码流程的。行号指示灯。



垃圾回收算法：

1. 标记-清除
2. 复制算法，内存分成两半，存活的移动到另一半
3. 标记-清除-整理 ： 清除完后，重新压缩整理
4. 分代收集算法

分代收集算法：

当前商业虚拟机的GC都是采用分代收集算法

![img](https://pic4.zhimg.com/80/v2-f150cbf353d76a91d039c00b82959baf_1440w.jpg)

新生代采用复制算法。新生代又分为Eden区和Survivor区（Survivor from、Survivor to），大小比例默认为8:1:1。

简单来说：

1 新对象优先分配在 Eden

2 Eden满了之后,minor garbage触发, Eden存活的复制进SuvivorFrom,SurvivorFrom复制到SurvivorTo.如果之前就存在，存活次数+1

3 存活年龄超过阈值之后 （默认是8，可配置）会移动到老年代

4 如果老年代也无法容纳，则进行Full GC（老年代一般是标记清除或者标记清除整理）

5 JVM中有个参数配置-XX:PretenureSizeThreshold，令大于这个设置值的对象直接进入老年代

>  新产生的对象优先进去Eden区，当Eden区满了之后再使用Survivor from，当Survivor from 也满了之后就进行Minor GC（新生代GC），将Eden和Survivor from中存活的对象copy进入Survivor to，然后清空Eden和Survivor from，这个时候原来的Survivor from成了新的Survivor to，原来的Survivor to成了新的Survivor from。复制的时候，如果Survivor to 无法容纳全部存活的对象，则根据老年代的分配担保（类似于银行的贷款担保）将对象copy进去老年代，如果老年代也无法容纳，则进行Full GC（老年代GC）。
>
> 大对象直接进入老年代：JVM中有个参数配置-XX:PretenureSizeThreshold，令大于这个设置值的对象直接进入老年代，目的是为了避免在Eden和Survivor区之间发生大量的内存复制。
>
> 长期存活的对象进入老年代：JVM给每个对象定义一个对象年龄计数器，如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳，将被移入Survivor并且年龄设定为1。没熬过一次Minor GC，年龄就加1，当他的年龄到一定程度（默认为15岁，可以通过XX:MaxTenuringThreshold来设定）



永久代一般不会回收，只有：

1. 类的所有实例都已经被回收
2. 加载类的ClassLoader已经被回收
3. 类对象的Class对象没有被引用（即没有通过反射引用该类的地方）

可能会回收



## 12. Java ClassLoader

BootStrap ClassLoader：称为启动类加载器，是Java类加载层次中最顶层的类加载器，负责加载JDK中的核心类库

Extension ClassLoader：称为扩展类加载器，负责加载Java的扩展类库

App ClassLoader：称为系统类加载器，负责加载应用程序classpath目录下的所有jar和class文件



每个 ClassLoader 都很懒，尽量把工作交给父亲做，父亲干不了了自己才会干.


